

알고리즘의 성능 : 시간과 공간 사용량의 효율성

ex 순차 탐색 vs 이분 탐색
- 정렬되지 않은 리스트에서 키 찾기 : 순차 탐색
- 정렬된 리스트에서 키 찾기 : 이분 탐색

알고리즘의 분석
- 정확성 분석 : 모든 입력 사례에 대해서 정확한 해답을 찾는다는 것을 증명(귀납적)
- 효율성 분석 : 입력 크기가 커지는 정도에 따라 성능의 변화량을 증명
  - 시간복잡도 time complexity
  - 공간복잡도 space complexity

알고리즘의 성능 분석
- 퍼포먼스 측정 : 실행시간을 직접측정 or 실행명령의 숫자세기
  - 컴퓨터의 성능이나 프로그래밍 언어에 따라 달라짐

- 복잡도 분석 : 컴퓨터나 프로그래밍 언어와 무관하게 성능 분석
  - 입력 크기(input, n)에 따른 단위 연산(알고리즘)의 실행 횟수 세기

복잡도 분석
- 입력크기 : 문제가 가진 파라미터, 즉 입력사례의 크기(n)
- 단위(Basic operation) 연산 : 알고리즘 실행의 기본이 되는 명령어들의 집합
  ex) 02 -> 단위연산 : 리스트의 원소를 result에 더하는 명령
            입력크기 : 리스트S의 원소 개수(n)
            for 문장은 항상 n번 실행하므로 시간복잡도 T(n) = n

 - 일정 시간 복잡도 : 입력 사례에 따라 달라지지 않는 경우
 - 최악, 최적, 평균 시간 복잡도 : 입력 사례에 따라 달라지는 경우

알고리즘의 차수
- T(n)의 차수가 높으면 궁극적으로(전체적으로 봤을때) 느리다고 할수 있다
- 차수(Order) : 알고리즘의 궁극적인 성능 분류
  -1차 시간 알고리즘 : 시간복잡도가 1차 함수인 알고리즘
  -2차 시간 알고리즘 : 시간복잡도가 2차 함수인 알고리즘
  - 근분원리 : 모든 1차 시간 알고리즘은 궁극적으로 2차 시간 알고리즘보다 빠르다

시간 복잡도의 분류 : 1. 다항시간 2. 지수시간

알고리즘의 성능을 차수로 분류하는 법
= 낮은 차수의 항들은 항상 버릴 수 있다.
--> 점근적 표기법
O(n) 빅오 표기법(복잡도 함수의 점근적 상한을 표기)
오메가(복잡도 함수의 점근적 하한을 표기)
세타(=차수)(복잡도 함수의 점근적 상한과 하한을 동시에 만족)

